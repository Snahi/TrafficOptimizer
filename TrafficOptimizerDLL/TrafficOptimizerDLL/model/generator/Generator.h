#pragma once
#include "../road/Road.h"
#include "../Car.h"
#include <list>
#include <string>
// const //////////////////////////////////////////////////////////////////////////////////////////
// tick
#define TICK_GENERATOR_SUCCESS 0
#define TICK_GENERATOR_WRONG_INIT 1
// obtain from string
#define UNIFORM_GENERATOR_STRING "uniform_generator"


class FirstCarGenerationListener;
class Car;
class Road;



/*
	Class which generates cars and puts them at the beginning of the road. One generator can
	generate cars only for one road. Only one generator can be assigned to a road, but generators
	can be combined so that diversified cars can be generated for the road. This is achieved by
	storing reference to the next generator. If the generator doesn't store reference to another
	generator, then it means that it is the last one in the chain and it will receive all generated
	cars from the previous generators if any. If the generator stores reference to another 
	generator it means that there are more generators before the road. If generator is not the 
	final one then after it generates a car it will forward it to the next generator. The last 
	generator in chain is responsible for putting cars in a queue if they are generated too fast.
*/
class Generator
{
public:
	// constructors ///////////////////////////////////////////////////////////////////////////////
	/*
		Constructor for the last generator in the chain of generators
	*/
	Generator(double periodOfGeneration, std::list<Car*>* pActiveCarsInModel, Car* pCarTemplate,
		Road* pRoad);
	/*
		Constructor for a generator which is not the last one it the chain of generators
	*/
	Generator(double periodOfGeneration, std::list<Car*>* pActiveCarsInModel, Car* pCarTemplate, 
		Road* pRoad, Generator* pNextGenerator);
	~Generator();

	// methods ////////////////////////////////////////////////////////////////////////////////////
	virtual void reset();
	static Generator* obtainFromString(std::string& type, std::vector<std::string>& parameters);
	/*
		Generates car if the time passed is appropriate.
		Returns:
			TICK_GENERATOR_SUCCESS		- object is properly initialized
			TICK_GENERATOR_WRONG_INIT	- object is not properly initialized
	*/
	int tick(double duration);
	// getters && setters 
	bool setGeneratedCarTemplate(Car* pCarTemplate);
	Car* getGeneratedCarTemplate();
	Road* getGeneratedCarTemplateFirstRoad();
	bool setRoad(Road* pRoad);
	Road* getRoad();
	void setActiveCarsInModel(std::list<Car*>* pActiveCarsInModel);
	void setNextGenerator(Generator* pNextGenerator);
	void registerFirstGenerationListener(FirstCarGenerationListener* pListener);
	void startGeneratingCarsForEvaluation();
	int getNumOfReadyCars();

protected:
	// fields /////////////////////////////////////////////////////////////////////////////////////
	/*
		Cars generated by the generator will be based on that car. Whether they will be exactly the
		same or they will be slightly modified for each generation depends on specific instance of
		the generator.
	*/
	Car* pGeneratedCarTemplate;
	/*
		Time for which the generator will distribute the cars. Once the time is reached timePassed
		is rest to 0.0
	*/
	double periodOfGeneration;
	/*
		Time passed since the first tick in a period
	*/
	double timePassed;
	double timeOfLastGeneration;

	// methods ////////////////////////////////////////////////////////////////////////////////////
	/*
		Returns true if car should be generated taking into consideration current time
	*/
	virtual bool shouldGenerateNow() = 0;
	/*
		Generates a car
	*/
	virtual Car* generate() = 0;
	bool isInitializedProperly();

private:
	// methods ////////////////////////////////////////////////////////////////////////////////////
	/*
		Whenever a car is generated it is passed further which can mean two things:
			1. if the generator is the last one (has reference to road)
				the car is put on road if possible (if not possible then to the queue)
			2. the generator is not the last one (has reference to other generator)
				the car is passed to the next generator which either passess it further or puts it
				on the road (as in point 1.)
	*/
	void pushCarFurther(Car* pCar);
	void pushCarFromQueue();

	// fields /////////////////////////////////////////////////////////////////////////////////////
	Generator* pNextGenerator;
	/*
		It can happen that the generator generates cars faster than the road can take them, and in
		that case the cars will be added to this queue and put on the road as soon as possible. The
		queue is a vector, not a list because the queue will keep small number of cars, so vector 
		will be faster.
	*/
	std::vector<Car*> carsQueue;
	/*
		Pointer to the list in which all the active cars of the model are stored. When cars are 
		successfully put on the road then they are added to that list.
	*/
	std::list<Car*>* pActiveCarsInModel;
	/*
		True if all initialization varibles were correct, false otherwise
	*/
	bool successfulInit;
	/*
		The template car must have the road as the first road
	*/
	Road* pRoad;
	/*
		The listener will be notified when the first car will be generated. It is used in model
		to determine when the first generated car reached the goal. The model needs it, because
		it shouldn't start counting statistics before all first cars reach the goal (that would
		be unreliable)
	*/
	FirstCarGenerationListener* pFirstGenerationListener;
	/*
		true if the first car was generated
	*/
	bool hasGeneratedCar;
};



class FirstCarGenerationListener
{
public:
	virtual void firstCarGenerated(Car* pCar) = 0;
};
